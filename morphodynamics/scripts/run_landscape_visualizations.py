#from xvfbwrapper import Xvfb
#vdisplay = Xvfb(width=1920, height=1080)
#vdisplay.start()

import numpy as np
import sys
import scipy
import matplotlib.pyplot as plt
import mpl_toolkits
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d import art3d
import matplotlib as mpl
import glob
import pickle
from mayavi import mlab
#mlab.options.offscreen=True
import cv2
from sklearn.neighbors import KernelDensity
import copy
from matplotlib import colors
import matplotlib.gridspec as gridspec
import os


drug_name = sys.argv[1]
landscape_or_errors = sys.argv[2]


xlims = [-13, 13]
ylims = [-13, 13]

path_to_here = os.path.dirname(os.path.realpath(__file__))
path_vis_data = os.path.join(path_to_here, '../data/landscape_visualizations/')
pList_data = os.path.join(path_to_here, '../data/embeddings/lims13/lims13_{}.pickle'.format(drug_name))


path_SDE_objects = path_vis_data + '{}/'.format(drug_name) # path with all the objects for plotting, after running inference on the PINN

UArray = path_SDE_objects + 'potential.pickle' # potential array
trajectories_subsampled = path_SDE_objects + 'subsampled_paths_p0.pickle' # subsampled paths of eq. 1
pList_NN = path_SDE_objects +  'p_list_0.pickle' # pdf generated by PINN at timepoints
DMSO_pList_NN = path_vis_data + 'DMSO/p_list_0.pickle' # same as above but for DMSO
idxs_plot_all = {'DMSO':[1, 2, 4, 6, 11, 17, 36, 37], 'compound_A':[105, 106, 132, 133, 145, 146, 147, 148], 'compound_X':[0, 1, 2, 3, 14, 15, 16, 18], 'compound_C_0_041':[0, 1, 2, 3, 20, 21, 22, 23, 24, 25], 'compound_C_10':[0, 1, 2, 3, 20, 21, 22, 23, 24, 25], 'compound_B':[0, 1, 2, 3, 5, 6, 31, 46, 82]}
idxs_plot = idxs_plot_all[drug_name] # indexes of simulations to see a spread of trajectories 




class Visualisations():

    def __init__(self, xlims, ylims,
                    pList_data, pList_NN, DMSO_pList_NN,
                    UArray,
                    trajectories_subsampled, idxs_plot):
        """
        - xlims, ylims: limits for plotting
        - pList_data: data pdfs
        - pList_NN: PINN pdfs
        - DMSO_pList_NN: PINN pdfs for DMSO
        - UArray: potential as an array
        - trajectories_subsampled: subsampled simulations of eq.1 (subsampled to reduce memory)
        - idxs_plot: indexes of simulations to see spread of trajectories as lots are the same
        """

        self.resize_size = (1000, 1000)
        self.idxs_plot = idxs_plot

        self.xlims, self.ylims = xlims, ylims

        self.pList_data = [np.reshape(i, (200, 200)) for i in pickle.load(open(pList_data, 'rb'))]
        self.pList_data = [cv2.resize(i, self.resize_size, interpolation = cv2.INTER_LINEAR) for i in self.pList_data]

        self.pList_NN = pickle.load(open(pList_NN, 'rb'))
        self.pList_NN = [cv2.resize(i, self.resize_size, interpolation = cv2.INTER_LINEAR) for i in self.pList_NN]

        self.DMSO_pList_NN = pickle.load(open(DMSO_pList_NN, 'rb'))
        self.DMSO_pList_NN = [cv2.resize(i, self.resize_size, interpolation = cv2.INTER_LINEAR) for i in self.DMSO_pList_NN]

        self.UArray = pickle.load(open(UArray, 'rb')).reshape((200, 200))
        self.UArray = cv2.resize(self.UArray, self.resize_size, interpolation = cv2.INTER_LINEAR)

        self.trajectories_subsampled = pickle.load(open(trajectories_subsampled, 'rb'))

    def _get_and_squeeze_largest_contour(self, im):
        """
        Removes a dimension of a contour so it's more usable.
        """
        contours, _ = cv2.findContours(im, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        areas = [cv2.contourArea(cont) for cont in contours]
        contour = contours[areas.index(max(areas))]
        contour = np.squeeze(contour, axis = 1)
        return contour

    def _get_DMSO_and_drug_outlines(self):
        """
        Gets outlines for DMSO and a drug to see outer limits of pdf
        """
        thresh = 5e-4
        minimum, divBy = -13, 1000/26

        DMSO_im = self.DMSO_pList_NN[-1]
        DMSO_im[DMSO_im<thresh] = 0
        DMSO_im[DMSO_im>thresh] = 255
        DMSO_im = DMSO_im.astype(np.uint8)
        DMSO_contour = self._get_and_squeeze_largest_contour(DMSO_im)
        DMSO_contour = [minimum+np.array(i)/divBy for i in DMSO_contour] # image size is 1000 therefore divide
        DMSO_contour.append(DMSO_contour[0])

        drug_im = self.pList_NN[-1]
        drug_im[drug_im<thresh] = 0
        drug_im[drug_im>thresh] = 255
        drug_im = drug_im.astype(np.uint8)
        drug_contour = self._get_and_squeeze_largest_contour(drug_im)
        drug_contour = [minimum+np.array(i)/divBy for i in drug_contour]
        drug_contour.append(drug_contour[0])

        return DMSO_contour, drug_contour


    def _points_to_xyzs(self, points):
        """
        Converts 2D points into lists of x, y & z values (z being height of the potential)
        """
        xs = [i[0] for i in points]
        ys = [i[1] for i in points]

        cols = [1000*(x-self.xlims[0])/(self.xlims[1]-self.xlims[0]) for x in xs]
        rows = [1000*(y-self.ylims[0])/(self.ylims[1]-self.ylims[0]) for y in ys]
        zs = []
        for idx in range(len(xs)):
            zs.append(0.1 + 10*self.UArray[int(rows[idx]), int(cols[idx])])

        return xs, ys, zs


    def gradient_colored(self, plot_every):
        """
        Landscape visualizations with eq.1 simulations
        - plot_every: plot every [plot_every] trajectories
        """

        figU = mlab.figure(size=(5000, 5000), bgcolor = (1, 1, 1))

        x = np.linspace(self.xlims[0], self.xlims[1], 1000)
        y = np.linspace(self.ylims[0], self.ylims[1], 1000)
        xg, yg = np.meshgrid(x, y)

        resolution = int(self.resize_size[0]/26.) # grid resolution

        # hide border so visualization is comparable with [-10, 10] morphospace plots
        self.UArray[:3*resolution, :] = np.nan
        self.UArray[23*resolution:, :] = np.nan
        self.UArray[:, :3*resolution] = np.nan
        self.UArray[:, 23*resolution:] = np.nan


        Gx, Gy = np.gradient(self.UArray, 20./1000, 20./1000) # gradients with respect to x and y
        G = (Gx**2+Gy**2)**.5  # gradient magnitude
        G[np.isinf(G)] = np.nan

        mesh = mlab.mesh(xg, yg, 10*self.UArray, scalars = G, figure = figU, colormap = 'jet', opacity = 1, vmin = 0, vmax = 0.2)
        mesh.actor.property.lighting = False

        # get and plot DMSO and drug outlines for outer limits of pdfs
        DMSO_contour, drug_contour = self._get_DMSO_and_drug_outlines()
        xs, ys, zs = self._points_to_xyzs(drug_contour)
        mlab.plot3d(xs, ys, zs, line_width = 8, figure = figU,  tube_radius=None, color = (1, 1, 1))
        xs, ys, zs = self._points_to_xyzs(DMSO_contour)
        mlab.plot3d(xs, ys, zs, line_width = 8, figure = figU,  tube_radius=None, color = (0, 0, 0))

        # plot the eq. 1 simulations
        count = 0
        for idx_traj, trajectory in enumerate(self.trajectories_subsampled):
            if count % plot_every == 0:
                if idx_traj in self.idxs_plot:
                    xs, ys, zs = self._points_to_xyzs(trajectory)
                    mlab.plot3d(xs, ys, zs, line_width = 3, figure = figU,  tube_radius=None, color = (1, 1, 1))
                    mlab.points3d(0.3+xs[0], ys[0], 0.3+zs[0], scale_factor = 0.7, color = (1, 0.4, 1), figure = figU)
                    mlab.points3d(0.3+xs[-1], ys[-1], 0.3+zs[-1], scale_factor = 0.7, color = (0, 0.9, 0.9), figure = figU)
                    count += 1


        #mlab.colorbar(orientation='vertical', nb_labels = 4)
        mlab.view(azimuth = 20, elevation = 60, distance = 70)
        #mlab.savefig(path_to_here+'/../outputs/landscape_{}.png'.format(drug_name), size = (100, 100))
        mlab.show()
        plt.show()


    def plot_sde_errors(self):
        """
        Plot the errors by comparing data with eq. 1 simulations
        """

        kdes_data_2 = open(path_SDE_objects + 'kdes_data_2.pickle', 'rb')
        kdes_data_2 = [np.reshape(i, (200, 200)) for i in pickle.load(kdes_data_2)]

        kdes_nn = open(path_SDE_objects + 'kdes_nn.pickle', 'rb')
        kdes_nn = [np.reshape(i, (200, 200)) for i in pickle.load(kdes_nn)]

        errors = [np.subtract(kdes_nn[idx], kdes_data_2[idx]) for idx in range(len(kdes_nn))]
        errors_max_abs = max([np.max(np.abs(i)) for i in errors])

        kde_max = max([np.max(i) for i in kdes_data_2+kdes_nn])
        log_kde_max = np.log10(kde_max)
        log_clip = -5


        num_cols = len(kdes_data_2)+1
        fig = plt.figure(figsize = (7, 2.5))
        gs = gridspec.GridSpec(3, num_cols)
        gs.update(wspace=0, hspace=0)

        for i in range(len(kdes_nn)):
            kdes_data_2[i] = np.clip(kdes_data_2[i], 10**log_clip, 100)
            kdes_nn[i] = np.clip(kdes_nn[i], 10**log_clip, 100)

        for idx in range(len(kdes_data_2)):
            ax1 = fig.add_subplot(gs[1+idx])
            ax2 = fig.add_subplot(gs[1+num_cols+idx])
            ax3 = fig.add_subplot(gs[1+2*num_cols+idx], aspect = 1)

            c1 = ax1.imshow(np.log10(kdes_data_2[idx]),  vmin = log_clip, vmax = log_kde_max, cmap = 'jet')
            ax2.imshow(np.log10(kdes_nn[idx]), vmin = log_clip, vmax = log_kde_max, cmap = 'jet')
            x = np.linspace(self.xlims[0], self.xlims[1], 200)
            y = np.linspace(self.ylims[0], self.ylims[1], 200)
            xg, yg = np.meshgrid(x, y)

            ax3.pcolormesh(x, y, errors[idx][::-1, :],
                                   norm=colors.SymLogNorm(linthresh=10**-2.5, linscale=0.000001, # 10**-2.72 is single particle
                                                          vmin=-0.2, vmax=0.2, base = 10),
                                   cmap='PiYG')


        ax = fig.add_subplot(gs[0])
        ax.set_visible(False)
        c2 = ax.imshow(np.array([[-1, 0, 1]]), cmap = 'PiYG')
        for ax in fig.axes:
            ax.tick_params(axis='both', which='both', bottom=False, left = False, labelleft = False, labelbottom=False)
        plt.subplots_adjust(hspace = 0, wspace = 0, right = 0.8)

        c1_loc = fig.add_axes([0.82, 0.50, 0.02, 0.25]) # left, bottom, width, height
        c1_bar = fig.colorbar(c1, cax=c1_loc, ticks=[log_clip, log_kde_max])
        c1_bar.ax.set_yticklabels([r'<$10^{{{}}}$'.format(log_clip), r'$10^{{{}}}$'.format(np.round(log_kde_max, 2))], fontsize = 6)

        c2_loc = fig.add_axes([0.82, 0.11, 0.02, 0.25]) # left, bottom, width, height
        c2_bar = fig.colorbar(c2, cax=c2_loc, ticks=[-1, 0, 1])
        c2_bar.ax.set_yticklabels([r'-$10^{{{}}}$'.format(np.round(np.log10(errors_max_abs), 2)), r'$\pm 10^{{{}}}$'.format(-2.5), r'$10^{{{}}}$'.format(np.round(np.log10(errors_max_abs), 2))], fontsize = 6)

        plt.savefig(path_to_here+'/../outputs/{}errors.png'.format(drug_name), dpi = 900)




if __name__ == '__main__':

    vis = Visualisations(xlims, ylims,
                    pList_data, pList_NN, DMSO_pList_NN,
                    UArray,
                    trajectories_subsampled, idxs_plot)

    if landscape_or_errors == 'landscape':
        vis.gradient_colored(plot_every = 1)
    elif landscape_or_errors == 'errors':
        vis.plot_sde_errors()
